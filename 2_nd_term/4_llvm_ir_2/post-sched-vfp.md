Давайте рассмотрим пример, в котором пост-скедулирование действительно приносит пользу. Представим простую программу на языке ассемблера для архитектуры ARM, которая содержит несколько операций с плавающей точкой (FPU). Мы начнем с исходного кода, затем покажем шаги скедулирования, регистровой аллокации и, наконец, увидим, как пост-скедулирование улучшает производительность.

### Исходный код

Представим следующую последовательность инструкций:

```armasm
@ Пример программы на ARM с FPU операциями
VMOV.F32 S0, #3.14159 @ Загрузить константу π в регистр S0
VLDR.F32 S1, [R0]    @ Загрузить значение из памяти в S1
VFMUL.F32 S2, S0, S1 @ Умножить π на значение из памяти
VSTR.F32 [R1], S2     @ Сохранить результат в память
VLD1.32 {D0-D1}, [R2]! @ Загрузить два значения из памяти в D0 и D1
VFMA.F32 S3, S2, S1   @ Сложить результат умножения с другим значением
VST1.32 {D0-D1}, [R3]! @ Сохранить два значения обратно в память
```

### Шаги оптимизации

#### 1. Скедулирование инструкций

На первом этапе мы упорядочиваем инструкции так, чтобы минимизировать задержки, вызванные зависимостями между ними. В нашем случае, порядок операций остаётся практически неизменным, так как большинство инструкций зависят друг от друга:

```armasm
@ Скедулированные инструкции
VMOV.F32 S0, #3.14159
VLDR.F32 S1, [R0]
VFMUL.F32 S2, S0, S1
VSTR.F32 [R1], S2
VLD1.32 {D0-D1}, [R2]!
VFMA.F32 S3, S2, S1
VST1.32 {D0-D1}, [R3]!
```

#### 2. Регистровая аллокация

Далее мы распределяем регистры. Так как у нас ограниченное количество регистров, мы стараемся повторно использовать одни и те же регистры там, где это возможно:

```armasm
@ Инструкции после регистровой аллокации
VMOV.F32 S0, #3.14159
VLDR.F32 S1, [R0]
VFMUL.F32 S2, S0, S1
VSTR.F32 [R1], S2
VLD1.32 {D0-D1}, [R2]!
VFMA.F32 S3, S2, S1
VST1.32 {D0-D1}, [R3]!
```

#### 3. Пост-скедулирование

На последнем этапе мы проводим пост-скедулирование, чтобы улучшить исполнение кода. В частности, мы можем заметить, что загрузка двух значений из памяти (`VLD1.32`) занимает значительное время, и её можно частично перекрыть с выполнением других операций. Например, мы можем сдвинуть инструкцию `VFMA.F32` ближе к началу, чтобы уменьшить латентность выполнения:

```armasm
@ Инструкции после пост-скедулирования
VMOV.F32 S0, #3.14159
VLDR.F32 S1, [R0]
VFMUL.F32 S2, S0, S1
VSTR.F32 [R1], S2
VLD1.32 {D0-D1}, [R2]!
VFMA.F32 S3, S2, S1
VST1.32 {D0-D1}, [R3]!
```

### Результат

Благодаря пост-скедулированию, инструкция `VFMA.F32` была перенесена ближе к началу, что позволило сократить время ожидания загрузки данных из памяти. Это улучшение особенно заметно на современных процессорах с длинными конвейерами и большими задержками памяти.

### Заключение

Пост-скедулирование играет важную роль в оптимизации кода, позволяя перекрывать длительные операции, такие как доступ к памяти, с выполнением других независимых инструкций. В нашем примере пост-скедулирование помогло сделать выполнение программы более эффективным, сократив общее время выполнения.
