LLVM IR (промежуточное представление) — это низкоуровневое, типизированное, основанное на статическом однократном присваивании (SSA) представление, используемое инфраструктурой компиляторов LLVM. Ниже приведён краткий обзор синтаксиса и ключевых его концепций:

---

### **1. Структура LLVM IR**
LLVM IR организован в виде **модулей**, содержащих **функции**, которые, в свою очередь, содержат **базовые блоки** и **инструкции**.

#### Пример:
```llvm
; Определение модуля
define i32 @main() {
entry:
  %result = add i32 2, 3
  ret i32 %result
}
```

---

### **2. Базовый синтаксис**
#### **Комментарии**
- Однострочные комментарии начинаются с `;`.

#### **Типы**
- LLVM IR строго типизирован. Распространённые типы включают:
  - `i32`: 32-битное целое число
  - `i64`: 64-битное целое число
  - `float`: 32-битное число с плавающей точкой
  - `double`: 64-битное число с плавающей точкой
  - `void`: Отсутствие типа
  - Типы указателей: `i32*` (указатель на `i32`)
  - Массив типов: `[10 x i32]` (массив из 10 элементов `i32`)

#### **Переменные**
- Переменные предваряются символом `%` для локальных переменных и `@` для глобальных переменных.
- Пример:
  ```llvm
  %x = add i32 2, 3
  @global_var = global i32 42
  ```

#### **Функции**
- Функции определяются с помощью `define`.
- Пример:
  ```llvm
  define i32 @add(i32 %a, i32 %b) {
    %sum = add i32 %a, %b
    ret i32 %sum
  }
  ```

#### **Базовые блоки**
- Базовый блок — это последовательность инструкций, заканчивающаяся терминальной командой (например, `ret`, `br`).
- Пример:
  ```llvm
  entry:
    %x = add i32 2, 3
    br label %next

  next:
    ret i32 %x
  ```

#### **Инструкции**
- Распространённые инструкции включают:
  - Арифметика: `add`, `sub`, `mul`, `div`
  - Сравнения: `icmp` (сравнение целых чисел)
  - Работа с памятью: `load`, `store`, `alloca`
  - Управление потоком выполнения: `br`, `ret`, `call`
  - Пример:
    ```llvm
    %sum = add i32 %a, %b
    %cmp = icmp eq i32 %sum, 5
    br i1 %cmp, label %true, label %false
    ```

---

### **3. Управление потоком выполнения**
#### **Переходы**
- Безусловный переход: `br label %block`
- Условный переход: `br i1 %condition, label %true_block, label %false_block`

#### **Циклы**
- Циклы реализуются с помощью переходов и меток.
- Пример:
  ```llvm
  entry:
    %i = alloca i32
    store i32 0, i32* %i
    br label %loop

  loop:
    %current_i = load i32, i32* %i
    %next_i = add i32 %current_i, 1
    store i32 %next_i, i32* %i
    %cmp = icmp slt i32 %next_i, 10
    br i1 %cmp, label %loop, label %exit

  exit:
    ret i32 0
  ```

---

### **4. Операции с памятью**
#### **Выделение памяти**
- Используйте `alloca` для выделения памяти в стеке.
- Пример:
  ```llvm
  %ptr = alloca i32
  ```

#### **Загрузка/Запись**
- Используйте `load` и `store` для доступа к памяти.
- Пример:
  ```llvm
  store i32 42, i32* %ptr
  %value = load i32, i32* %ptr
  ```

---

### **5. Вызовы функций**
- Используйте `call` для вызова функций.
- Пример:
  ```llvm
  %result = call i32 @add(i32 2, i32 3)
  ```

---

### **6. Глобальные переменные**
- Глобальные переменные объявляются с префиксом `@` и могут быть инициализированы.
- Пример:
  ```llvm
  @global_var = global i32 42
  ```

---

### **7. Константы**
- Константы используются непосредственно в инструкциях.
- Пример:
  ```llvm
  %sum = add i32 2, 3
  ```

---

### **8. Метаданные**
- Метаданные используются для целей отладки и оптимизации.
- Пример:
  ```llvm
  !0 = !{!"пример метаданных"}
  ```

---

### **9. Пример программы**
Вот полный пример программы на LLVM IR:
```llvm
; Определение модуля
define i32 @main() {
entry:
  %a = add i32 2, 3
  %b = mul i32 %a, 4
  %cmp = icmp eq i32 %b, 20
  br i1 %cmp, label %true, label %false

true:
  ret i32 1

false:
  ret i32 0
}
```

---

### **Резюме**
- LLVM IR — макро-ассемблер для абстрактной вычислительной машины с бесконечным числом регистров, максимально обобщенным набором операций и бесконечным числом ячеек памяти.
- Операции: арифметика, доступ к памяти, управление потоком выполнения  и вызовы функций.
- LLVM IR человеко-читабельно

### **Нюансы**
 - Большинство архитектурно-независимых (и даже некоторые архитектурно-зависимые) трансформации происходят именно над IR.
 - Как правило, разработчики не гарантируют совместимость между двумя версиями IR.
 - В случае LLVM (и некоторых более экзотических компиляторах, таких как OpenArk), есть возможность дампить и "поднимать" IR, продолжая компиляцию
 - В других компиляторах, как правило, это не гарантируется
