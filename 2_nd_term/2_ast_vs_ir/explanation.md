+-------------------+       +-------------------+       +-------------------+
|                   |       |                   |       |                   |
|   C Source Code   |       |   Abstract Syntax |       |   LLVM IR Code    |
|                   |       |   Tree (AST)      |       |                   |
|  int main() {     |       |                   |       |  define i32 @main |
|    int a = 10;    |       |  FunctionDecl     |       |  () {             |
|    int b = 20;    |  -->  |  |-VarDecl (a)    |  -->  |    %a = alloca i32|
|    int c = a + b; |       |  |-VarDecl (b)    |       |    store i32 10,  |
|    return c;      |       |  |-BinaryOperator |       |      i32* %a      |
|  }                |       |  |-ReturnStmt     |       |    %b = alloca i32|
|                   |       |                   |       |    store i32 20,  |
+-------------------+       +-------------------+       |      i32* %b      |
                                                       |    %1 = load i32, |
                                                       |      i32* %a      |
                                                       |    %2 = load i32, |
                                                       |      i32* %b      |
                                                       |    %c = add i32   |
                                                       |      %1, %2       |
                                                       |    ret i32 %c     |
                                                       |  }                |
                                                       +-------------------+



## Анализ AST: Libclang


## Сравнение Abstract Syntax Tree (AST) и Intermediate Representation (IR)

### Abstract Syntax Tree (AST)

**Определение:**  
AST представляет собой структурированное представление исходного кода программы, отражающее грамматические правила языка программирования. Оно создается на этапе парсинга и служит основой для дальнейших шагов компиляции, таких как семантический анализ, оптимизация и генерация кода.

**Особенности:**
- **Отражает синтаксис языка.** AST содержит иерархию объектов, представляющих элементы программы, такие как выражения, операторы, функции и переменные.
- **Независимость от конкретной реализации языка.** AST абстрагируется от мелких деталей лексики, таких как пробелы, комментарии и символы конца строки.
- **Удобство для анализа и трансформации кода.** AST часто используется для автоматического рефакторинга, генерации документации и других операций над исходным кодом.

**Преимущества:**
- **Понятность и простота чтения.** Разработчики могут легко интерпретировать AST, так как оно соответствует структуре исходного кода.
- **Широкий спектр применений.** AST подходит для статического анализа, автоматизированного тестирования и проверки качества кода.
- **Поддержка рефакторинга.** Позволяет автоматизировать изменение кода, сохраняя смысл программы.

**Недостатки:**
- **Зависимость от языка программирования.** Каждая версия AST специфична для конкретного языка программирования.
- **Трудоемкость оптимизации.** AST может содержать избыточные детали, усложняющие дальнейшую оптимизацию.
- **"Разрастание"** Чтобы выделить некоторую семантическую единицу, приходится обходить все некотрое поддеререво, которое может оказаться большим.

---

### Intermediate Representation (IR)

**Определение:**  
IR — это промежуточное представление программы, используемое компилятором для упрощения и оптимизации кода перед генерацией исполняемого файла. IR обычно представляет программу в виде (граф-структурируемого) набора инструкций низкого уровня, максимально приближенных "в общем" к архитектурам целевых машин. 



**Особенности:**
- **Независимость от архитектуры и входного языка.** IR представляет код в форме, понятной независимо от целевой платформы и исходного языка.
- **Оптимизации высокого уровня.** IR позволяет проводить сложные оптимизации, такие как удаление мертвых кодов, векторизация и распределенная обработка.
- **Генерация кода для разных платформ.** IR обеспечивает основу для кросс-компиляции, позволяя одному компилятору поддерживать разные архитектуры.

**Преимущества:**
- **Улучшенная производительность.** IR оптимизирует выполнение программы, удаляя ненужные операции и улучшая параллелизм.
- **Кросс-платформенность.** IR облегчает поддержку множества архитектур и операционных систем.
- **Простота дальнейшего анализа.** IR упрощает проведение низкоуровневых проверок, таких как безопасность памяти и контроль ресурсов.

**Недостатки:**
- **'Сложность понимания'.** IR сложнее для восприятия человеком, особенно при работе с высокоуровневыми языками.
- **Ограниченность реверс-инжиниринга.** Из IR труднее восстановить исходный код, что затрудняет отладку и восстановление логики программы.

---

### Сводная таблица сравнения

| Критерий                 | AST                                           | IR                                  |
|--------------------------|-----------------------------------------------|-------------------------------------|
| **Цель использования**   | Анализ и трансформация исходного кода           | Оптимизация и генерация кода          |
| **Зависимость от языка** | Да                                            | Нет                                 |
| **Понятность человеку**  | Высокая                                        | Низкая                               |
| **Оптимизация**          | Локальная, синтаксически ориентированная       | Глобальная, архитектура-зависимая     |
| **Применение**           | Рефакторинг, статический анализ                | Кросс-компиляция, низкоуровневые оптимизации |
| **Удобство восстановления исходного кода** | Высокое                         | Низкое                                |

---

## Заключение

AST и IR служат разным целям в процессе компиляции и анализа программного кода. AST полезен для манипуляций с исходным кодом, тогда как IR оптимален для повышения производительности и портативности программы. Выбор между ними зависит от конкретной задачи и требований проекта.


---
Преобразование AST в IR

На этом этапе AST преобразуется в IR. IR представляет собой более низкое и унифицированное представление программы, независимое от исходного языка программирования и близкое к архитектуре целевого устройства. Вот основные шаги этого процесса:
Разбор AST и выбор инструкций IR: Компилятор просматривает каждый узел AST и генерирует соответствующие инструкции IR. Например, арифметическое выражение в AST может быть преобразовано в последовательность инструкций сложения и умножения в IR.
Упрощение выражений: Некоторые конструкции языка могут быть упрощены до более простых форм. Например, вложенные условные операторы могут быть заменены на последовательности базовых ветвлений.
Обработка областей видимости: Переменные и функции обрабатываются таким образом, чтобы учесть их области видимости и возможные конфликты имен.
Оптимизация: На этом этапе могут применяться начальные оптимизации, такие как устранение неиспользуемых переменных или выведение общих подвыражений.
---
