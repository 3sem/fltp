from typing import List, Dict, Set, Tuple

class TwoSidedContextCYK:
    def __init__(self, grammar: Dict, left_context: Dict, right_context: Dict, start_symbol: str):
        """
        Initialize the parser with:
        - grammar: Dict of productions (e.g., {"A": [["B", "C"]]})
        - left_context: Dict mapping nonterminals to their left context requirements (e.g., {"A": {"X"}})
        - right_context: Dict mapping nonterminals to their right context requirements (e.g., {"A": {"Y"}})
        - start_symbol: The root nonterminal (e.g., "S")
        """
        self.grammar = grammar
        self.left_context = left_context
        self.right_context = right_context
        self.start_symbol = start_symbol

    def parse(self, input_string: str) -> bool:
        """
        Parses the input string and returns True if it can be generated by the grammar.
        """
        n = len(input_string)
        if n == 0:
            return False

        # Initialize CYK chart: C[i][j] = set of nonterminals spanning i to j
        C = [[set() for _ in range(n+1)] for _ in range(n+1)]

        # Fill in terminals (base case)
        for i in range(1, n+1):
            char = input_string[i-1]
            for A, productions in self.grammar.items():
                for prod in productions:
                    if len(prod) == 1 and prod[0] == char:
                        # Check left context (if any)
                        left_ok = True
                        if A in self.left_context:
                            left_ok = self._check_left_context(A, i-1, C)
                        
                        # Check right context (if any)
                        right_ok = True
                        if A in self.right_context:
                            right_ok = self._check_right_context(A, i, C, n)
                        
                        if left_ok and right_ok:
                            C[i][i].add(A)

        # Fill in nonterminals (dynamic programming)
        for length in range(2, n+1):          # Span length
            for i in range(1, n - length + 2): # Start position
                j = i + length - 1            # End position
                for k in range(i, j):          # Partition point
                    for A, productions in self.grammar.items():
                        for prod in productions:
                            if len(prod) == 2:  # Only handle binary productions (A â†’ BC)
                                B, C = prod
                                if B in C[i][k] and C in C[k+1][j]:
                                    # Check left context (if any)
                                    left_ok = True
                                    if A in self.left_context:
                                        left_ok = self._check_left_context(A, i-1, C)
                                    
                                    # Check right context (if any)
                                    right_ok = True
                                    if A in self.right_context:
                                        right_ok = self._check_right_context(A, j, C, n)
                                    
                                    if left_ok and right_ok:
                                        C[i][j].add(A)

        # Check if the start symbol spans the entire string
        return self.start_symbol in C[1][n]

    def _check_left_context(self, A: str, pos: int, C: List[List[Set[str]]]) -> bool:
        """Returns True if the left context of A is satisfied at position pos."""
        if pos < 1:
            # At start of string, check if left_context allows it
            return True  # Modify if needed for specific grammar rules
        required = self.left_context.get(A, set())
        if not required:
            return True
        # Check if any required left context symbol appears somewhere before pos
        for x in range(1, pos + 1):
            for y in range(x, pos + 1):
                for symbol in C[x][y]:
                    if symbol in required:
                        return True
        return False

    def _check_right_context(self, A: str, pos: int, C: List[List[Set[str]]], n: int) -> bool:
        """Returns True if the right context of A is satisfied at position pos."""
        if pos > n:
            # At end of string, check if right_context allows it
            return True  # Modify if needed for specific grammar rules
        required = self.right_context.get(A, set())
        if not required:
            return True
        # Check if any required right context symbol appears somewhere after pos
        for x in range(pos, n + 1):
            for y in range(x, n + 1):
                for symbol in C[x][y]:
                    if symbol in required:
                        return True
        return False
