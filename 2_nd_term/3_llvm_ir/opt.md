Базовый блок: (basic block) — участок программы, в котором: начало — точка перехода;
последняя операция — переход (условный/безусловный); других точек перехода и переходов нет.

Граф потока управления: (control flow graph, CFG) — ориентированный граф программы, где вершины — все базовые блоки;
дуги — возможные переходы.

SSA-форма: (static single assignment form) — представление программы, в котором:
каждая переменная присваивается ровно 1 раз; каждая переменная определена перед использованием; для представления переменных, принимающих значения из разных базовых блоков, используются φ-вершины.

---

Основные оптимизации:

- Свёртка констант (constant folding).
- Распространение констант (constant propagation).
- Удаление тупиковых записей (dead store elimination).
- Удаление мёртвого кода (dead code elimination).
- Удаление общих подвыражений (common subexpression elemenation). Подстановка функций (inlining).
- Планирование инструкций (instruction scheduling).*

- Цикловые оптимизации (например, размотка циклов)**

* Могут приводить (** Точно приводят) к трейд-оффу между производительностью/размером кода и др

---

Свертка констант:

double y = 2 * sin(0.5) * x;

| Рассчитать итоговую константу (например, посредством встроенного в компилятор вызова) --> влияние арифметики чисел
|
V
double y = (...) * x

Распространение констант:

double pi = 3.1415; 
double l = 2 * pi * r;
| Подставить (заинлайнить) константу (+транзитивность) --> влияние арифметики чисел
|
V
double l = 2 * 3.1415 * r;

---

Удаление тупиковых записей (DSE)

int f(int a, int b) {
    int c = a + b;
    int z = 1 + c * c;
    c = a * b;
    return z;
}

---

Удаление мертвого кода (DCE)

- Тупиковые записи
- Недостижимый код
- Вычисление значений, используемых в мертвом коде

+ Удаляет лишний код-результат других оптимизаций
---

Сокращение общих подвыражений

x = cos(v) * (1 + sin(u / 2)) + sin(w) * (1 - sin(u / 2));
|
|
V
t = sin(u / 2);
x = cos(v) * (1 + t) + sin(w) * (1 - t);

В большинстве случаев уменьшает размер и время выполнения программы.

Может удалять выражения, которые недоступны пользователю (индексирование элементов массива, подстановка макросов, языковые конструкции, . . . )

Недостатки:
- Возможное возрастание нагрузки на регистры.
- Код-таки может разрастаться

Локальное: (LCSE) — в пределах базовых блоков (basic block). 
Глобальное: (GCSE) — в пределах функций.

---

Inlining
- Имеет смысл, если функция содержит относительно мало инструкций
и использует значительную долю времени выполнения ⇒ затраты
на вызов (копирование аргументов, инициализация стека) значительны.
- Может повысить эффективность дальнейших преобразований, когда все функции слиты в одну (CSE, . . . )

Недостатки:
- Код разрастается
- В большинстве случаев затраты на вызов функций незначительны по сравнению с общим временем работы программы

Когда выгодно:
- Есть только одна (или по крайней мере немного) точка вызова функции.
- Вызов функции требует больше инструкций/памяти, чем исполнение тела функции в месте вызова (простые функции доступа).

Особенности:

- Компилятор выбирает функции для подстановки на основе ряда эвристик (малый размер, . . . )
- Выполняется в пределах каждого объектного модуля (если не учитывать LTO)
- Можно явно запросить при помощи ключевого слова inline.

---

Раскрутка циклов:

-Минимизация промахов ветвления (branch penalty).
-Независимые операторы ⇒ могут выполняться параллельно.
-Лучшая загрузка оборудования при конвейеризации.
-Может выполняться динамически, если количество итераций неизвестно во время компиляции.


Недостатки:

-Увеличение размеров кода (промахи кэша инструкций). 
-Противоречие с подстановкой функций.
-Возможно увеличение количества используемых регистров для временных значений.
-Наличие условных операторов сильно замедляет выполнение
