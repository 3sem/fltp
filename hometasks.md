Домашка-1: контест "строки и конечные автоматы": http://judge2.vdi.mipt.ru/cgi-bin/new-register?contest_id=220221

Домашка-2: написать построение Томпсона regexp --> NFA, вывод NFA -- в json формате, используемом на семинарах (p1/examples/transform)

Домашка-3: написать свою flex-спецификацию утилиты wc, сравнить по времени работы с unix-овой утилитой и простейшей имплементацией из репозитория (p2/examples/flex/wc.l) на каком-нибудь большом входном тексте, постараться победить по времени.

Домашка-4: контест "лексический анализ и регулярные выражения": http://judge2.vdi.mipt.ru/cgi-bin/new-register?contest_id=220222

Домашка-5: посмотрите (p3) CYK для строк и графов, либо напишите свою реализацию. Подумайте, как соптимизировать по времени и по памяти  CYK для графов.

Домашка-6: Возьмите CYK для КС-достижимости на графах: https://github.com/nefanov/fltp/blob/main/p3/CYK_graph_naive.py . Попробуйте решить на нём следующую задачу -- восстановить все возможные деревья разбора для случая, когда путей в графе, подходящих под шаблон -- бесконечное число. Реализуйте SPPF на Вашем любимом ЯП.

Домашка-7. Исследовать рекурсивный спуск в Clang:
1.
'''
1) Выкачиваем llvm из репозитория llvm-project на github
2) mkdir build && cd build
3) cmake -DLLVM_ENABLE_PROJECTS=clang -G "Unix Makefiles" ../llvm -DCMAKE_BUILD_TYPE=debug 
4) make -j<number_of_jobs>
5) пишем программу, содержащую исследуемый код, например static int a,b,c,d,e,f = 5;
6) запускаем компиляцию под отладчиком: lldb -- clang -cc1 -emit-obj <program_name>.c
7) ставим брейкпоинты на функции вида parse<Something>. Определить, что за <Something> у a,b,c,d,e,f ? Для этого глазами смотрим AST-дерево: clang -cc1 -ast-dump 1.c
8) b parse<Something> для каждой функции. Затем r; Затем bt на каждом брейкпоинте. Проследите за передачей ключевых аргументов от фрейма к фрейму: frame select <NumOfFrame>
9) Выведите трассы вызовов для каждого брейкпоинта, определите, какую последовательность вызовов они проходят от корневого Parse (считать его нетерминалом S).
  
2. Попытайтесь поймать ситуации с лексером, описанные в t13/clang_frontend.pdf
'''
