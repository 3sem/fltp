# Рекурсивный спуск

Идея рекурсивного спуска: используем программный стек вызовов в качестве стека магазинного автомата.

- Для каждого нетерминала создаётся функция, принимающая ещё не обработанный остаток строки и возвращающая пару: 

(
результат вывода префикса данной строки из соответствующего нетерминала,
необработанный остаток строки
)

 В конце получим ответ "true" / "false" -- выводится / не выводится.
- Каждая такая функция реализует обработку цепочки согласно правым частям правил для соответствующих нетерминалов: 
считывание символа входа при обработке терминального символа, вызов соответствующей функции при обработке нетерминального.

Ограничения:

1. Не работает с грамматиками, в которых вывод может принимать следующий вид: S → ··· → N_iα → ···N_iβ → ···ω

Такие грамматики называют леворекурсивными.

2. Шаги должны быть однозначными.

Если возвращаеммое значение этой функции — пара вида (true, []), то разбор завершился успехом.

Данный подход применяется как для ручного написания синтаксических анализаторов, как это реализовано в Clang, так и при генерации анализаторов по грамматике, как это реализовано в библиотеке Boost C++.

