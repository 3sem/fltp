# Рекурсивный спуск

Наиболее интуитивный способ нисходящего анализа. Он опирается на то, мы можем написать набор рекурсивных функций для нашей грамматики, а стеком будет стек их вызовов.

Идея рекурсивного спуска: используем программный стек вызовов в качестве стека магазинного автомата.

- Для каждого нетерминала создаётся функция, принимающая ещё не обработанный остаток строки и возвращающая пару: 

(
результат вывода префикса данной строки из соответствующего нетерминала,
необработанный остаток строки
)

 В конце получим ответ "true" / "false" -- выводится / не выводится.
- Каждая такая функция реализует обработку цепочки согласно правым частям правил для соответствующих нетерминалов: 
считывание символа входа при обработке терминального символа, вызов соответствующей функции при обработке нетерминального.

Ограничения:

1. Не работает с грамматиками, в которых вывод может принимать следующий вид: S → ··· → N_iα → ···N_iβ → ···ω

Такие грамматики называют леворекурсивными.

2. Шаги должны быть однозначными.

Если возвращаеммое значение этой функции — пара вида (true, []), то разбор завершился успехом.

Данный подход применяется как для ручного написания синтаксических анализаторов, как это реализовано в Clang, так и при генерации анализаторов по грамматике, как это реализовано в библиотеке Boost C++.

Варианты реализации:

- Предсказывающий парсер
Для парсеров этого типа нужна подходящая КС-грамматика, конкретно LL(k) грамматика, позволяющая по очередному токену или токенам однозначно выбрать (предсказать) один из альтернативных вариантов раскрытия каждого нетерминала.

Такой парсер работает за линейное время.

Вариантом его является LL-парсер — реализация предсказывающего парсера с автоматическим построением «таблицы предсказания», определяющей по заданному нетерминалу и очередному токену подходящее правило для раскрытия нетерминала.

- Парсер с возвратом
Вместо предсказания парсер просто пытается применить все альтернативные варианты правил по порядку, пока одна из попыток не увенчается успехом.

Такой парсер может потребовать экспоненциального времени работы, и не всегда гарантирует завершение, в зависимости от грамматики. Уязвим для левой рекурсии.
