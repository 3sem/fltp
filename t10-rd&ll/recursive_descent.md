# Рекурсивный спуск

Наиболее интуитивный способ нисходящего анализа. Он опирается на то, мы можем написать набор рекурсивных функций для нашей грамматики, а стеком будет стек их вызовов. F(substr, prefix) --> (result, tail).

Идея рекурсивного спуска: используем программный стек вызовов в качестве стека магазинного автомата.

- Для каждого нетерминала создаётся функция, принимающая ещё не обработанный остаток строки и возвращающая пару: 

(
результат вывода префикса данной строки из соответствующего нетерминала,
необработанный остаток строки
)

 В конце получим ответ "true" / "false" -- выводится / не выводится.
- Каждая такая функция реализует обработку цепочки согласно правым частям правил для соответствующих нетерминалов: 
считывание символа входа при обработке терминального символа, вызов соответствующей функции при обработке нетерминального.

Ограничения:

1. Не работает с грамматиками, в которых вывод может принимать следующий вид: S → ··· → N_iα → ···N_iβ → ···ω (*)

Такие грамматики называют леворекурсивными. Рекурсия может быть как явной (2 последовательных шага), так и скрытой (более 2-х, и не на каждом).

2. Шаги должны быть однозначными.

Если возвращаеммое значение этой функции — пара вида (true, []), то разбор завершился успехом.

Пример (Python): для строк a^nb^n, n>=0: S->aSb|eps

```
def RD(w):
    def S(w):
        if len(w)==0:
            return (True,w)
        if (w.startswith("a")):
            res = S(w[1:-1])
            if res[0] and w.endswith('b'):
                return (True, res[1][1:])
            else:
                return (False, res[1])
        else:
            return (False, w)

    return S(w) # starting from production with S in the left side
        
if __name__=="__main__":  
    print(RD("aaabb")[0])
    print(RD("aaaaabbbbb")[0])
    print(RD("")[0])
    print(RD("abab")[0])
```

Пример (C): 

http://www.cs.binghamton.edu/~zdu/parsdemo/recintro.html

Данный подход применяется как для ручного написания синтаксических анализаторов, как это реализовано в Clang, так и при генерации анализаторов по грамматике, как это реализовано в библиотеке Boost C++.

Варианты реализации:

- Предсказывающий парсер
Для парсеров этого типа нужна подходящая КС-грамматика, конкретно LL(k) грамматика, позволяющая по очередному токену или токенам однозначно выбрать (предсказать) один из альтернативных вариантов раскрытия каждого нетерминала.

Такой парсер работает за линейное время.

Вариантом его является LL-парсер — реализация предсказывающего парсера с автоматическим построением «таблицы предсказания», определяющей по заданному нетерминалу и очередному токену подходящее правило для раскрытия нетерминала.

- Парсер с возвратом
Вместо предсказания парсер просто пытается применить все альтернативные варианты правил по порядку, пока одна из попыток не увенчается успехом.

Такой парсер может потребовать экспоненциального времени работы, и не всегда гарантирует завершение, в зависимости от грамматики. Уязвим для левой рекурсии.
