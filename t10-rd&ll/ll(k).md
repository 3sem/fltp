LL(k) — алгоритм синтаксического анализа —- нисходящий анализ без отката, но с предпросмотром. 
Решение о том, какую продукцию применять, принимается на основании предпросмотра k следующих за текущим символом символов. 

Временная сложность алгоритма на слове длины n -- O(n).

Для разбора создаётся вспомогательный буфер символов (токенов), стек и таблица, управляющая разбором.
Также понадобится символ конца строки, обозначим его $.

Каждая ячейка управляющей таблицы содержит правило, которое нужно применять, если рассматривается нетерминал A, а следующие m символов строки —- t_1 . . . t_m, где m ≤ k, также выделен столбец для $.

**Множества FIRST_k и FOLLOW_k**

Для построения таблицы строятся 2 множества -- FIRST_k и FOLLOW_k. Их строгое определение дано в конспекте лекций.

Идея: FIRST_k содержит k первых символов в результирующем выводе при использовании нетерминала A, FOLLOW_k -- k последующих.

Для k=1 определения принимают вид:

FIRST(A)={c∣A⇒∗cβ}∪{ε if A⇒∗ε}

FOLLOW(A)={c∣S⇒∗αAcβ}∪{$ if S⇒∗αA}

**Правила вычисления множества FIRST_k:**

Для k=1 правила примут следующий вид:

Если x -- терминал, то FIRST(x) = { x }
Если есть продукция X -> Є, то нужно добавить Є в FIRST(x).
Если есть продукция X->Y_1 Y_2 Y_3….Y_n , то FIRST(X) = FIRST(Y_1)
Если FIRST(Y_1) содержит Є, то FIRST(X) = { FIRST(Y_1) – Є } U { FIRST(Y_2) }
Если FIRST(Y_i) содержит Є,  i = 1..n, то нужно добавить Є в FIRST(X).

**FOLLOW_k можно вычислить, используя следующие правила и FIRST_k:**

Для k=1:

FOLLOW(S) = { $ }

Если рассматривается продукция A -> pBq где p, B, q \in N U T, тогда все элементы FIRST(q) \ {Є} \in FOLLOW(B).

Если рассматриваются продукции A -> aB, либо A -> aBb, такая что FIRST(b) содержит Є, то всё FOLLOW(A) содержится в FOLLOW(B)

Пример для k=1:

S -> Aa | Ac
A -> b

FIRST(S) = FIRST(Aa) U FIRST(Ac) = { b }

FIRST(A) = {b}

FOLLOW[S] == {$}

FOLLOW[A] == {a,c}








