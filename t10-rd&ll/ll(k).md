### — алгоритм синтаксического анализа

LL(k) — алгоритм нисходящего анализа с предпросмотром на k символов вперёд от текущего символа, и без откатов. На основании предпросмотра принимается решение, какую продукцию применять. Из такого неформального определения сразу видно, что у классического алгоритма будут проблемы с неоднозначными грамматиками. Две других (как минимум) проблемы, связанных с разрастанием вспомогательных данных и ограничениях на вид правил, мы рассмотрим позже.

Временная сложность алгоритма на слове длины n -- **O(n)**.

Для разбора создаётся вспомогательный буфер символов (токенов), стек и таблица, управляющая разбором. Она просчитывается один раз при подготовке парсера.
Также понадобится символ конца строки, обозначим его $.

Каждая ячейка управляющей таблицы содержит правило, которое нужно применять, если рассматривается нетерминал A, а следующие m символов строки —- t_1 . . . t_m, где m ≤ k, также выделен столбец для $.

**Множества FIRST_k и FOLLOW_k**

Для построения таблицы строятся 2 множества -- FIRST_k и FOLLOW_k. Их строгое определение будет дано в конспекте лекций.

Идея: FIRST_k содержит k первых символов в результирующем выводе при использовании нетерминала A, FOLLOW_k -- k последующих.

**Для k=1 определения принимают вид** (нижний индекс, как правило, опускают):

FIRST(A)={c∣A⇒∗cβ}∪{ε if A⇒∗ε}

FOLLOW(A)={c∣S⇒∗αAcβ}∪{$ if S⇒∗αA}

**Правила вычисления множества FIRST_k:**

Для k=1 правила примут следующий вид:

Если x -- терминал, то FIRST(x) = { x }
Если есть продукция X -> Є, то нужно добавить Є в FIRST(x).
Если есть продукция X->Y_1 Y_2 Y_3….Y_n , то FIRST(X) = FIRST(Y_1)
Если FIRST(Y_1) содержит Є, то FIRST(X) = { FIRST(Y_1) – Є } U { FIRST(Y_2) }
Если FIRST(Y_i) содержит Є,  i = 1..n, то нужно добавить Є в FIRST(X).

**FOLLOW_k можно вычислить, используя следующие правила и FIRST_k:**

Для k=1:

FOLLOW(S) = { $ }

Если рассматривается продукция A -> pBq где p, B, q \in N U T, тогда все элементы FIRST(q) \ {Є} \in FOLLOW(B).

Если рассматриваются продукции A -> aB, либо A -> aBb, такая что FIRST(b) содержит Є, то всё FOLLOW(A) содержится в FOLLOW(B)

Пример для k=1:

S -> Aa | Ac
A -> b

FIRST(S) = FIRST(Aa) U FIRST(Ac) = { b }

FIRST(A) = {b}

FOLLOW[S] == {$}

FOLLOW[A] == {a,c}








