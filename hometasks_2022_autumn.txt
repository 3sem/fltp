Домашка-1: контест "строки и конечные автоматы": http://judge2.vdi.mipt.ru/cgi-bin/new-register?contest_id=220221

-----------------------------------------------------------------------------------------------------------------

Домашка-2: Разработать свою библиотеку (или набор скриптов) для работы с регулярными выражениями.
Как вариант решения, для перевода regexp-->NFA можно использовать построение Томпсона regexp --> NFA, далее -- детерминизация NFA, минимизация DFA, вывод DFA/NFA -- в json формате, используемом на семинарах (p1/examples/transform)

-----------------------------------------------------------------------------------------------------------------

Домашка-3: написать свою flex-спецификацию утилиты wc, сравнить по времени работы с unix-овой утилитой и простейшей имплементацией из репозитория (p2/examples/flex/wc.l) на каком-нибудь большом входном тексте, постара

-----------------------------------------------------------------------------------------------------------------

Домашка-4: посмотрите (p3) CYK для строк и графов, либо напишите свою реализацию. Подумайте, как соптимизировать по времени и по памяти  CYK для графов.
(Для зачета этой домашки нужно предоставить соптимизированный код, либо взять готовый, но проанализировать на наличие неоптимальностей и "узких мест", предоставить отчет.

-----------------------------------------------------------------------------------------------------------------

Домашка-5: Возьмите CYK для КС-достижимости на графах: https://github.com/nefanov/fltp/blob/main/p3/CYK_graph_naive.py . Попробуйте решить на нём следующую задачу -- восстановить все возможные деревья разбора для случая, когда путей в графе, подходящих под шаблон -- бесконечное число. Реализуйте SPPF на Вашем любимом ЯП.

-----------------------------------------------------------------------------------------------------------------

Домашка-6. Домашка  по Бизону — нужно будет сгенерировать LALR(1)-парсер для правильных скобочек с несколькими типами скобок и подсчётом глубины вложенности каждого типа
Например, для ([((()[]))]([])) максимальная глубина для [] — 2, для () — 4
Вместо бизона можно пользоваться antlr, etc (Ваш любимый lr-генератор)

-----------------------------------------------------------------------------------------------------------------

Домашка-7. Clang

Исследовать рекурсивный спуск в Clang:

1) Выкачиваем llvm из репозитория llvm-project на github
2) mkdir build && cd build
3) cmake -DLLVM_ENABLE_PROJECTS=clang -G "Unix Makefiles" ../llvm -DCMAKE_BUILD_TYPE=debug 
4) # Для ускорения компиляции добавьте ещё флаги, которые отключают ненужные таргеты и включают только нужные инструменты
5) make -j<number_of_jobs>
6) пишем программу, содержащую исследуемый код, например static int a,b,c,d,e,f = 5;
7) запускаем компиляцию под отладчиком: lldb -- clang -cc1 -emit-obj <program_name>.c
8) ставим брейкпоинты на функции вида parse<Something>. Определить, что за <Something> у a,b,c,d,e,f ? Для этого глазами смотрим AST-дерево: clang -cc1 -ast-dump 1.c
9) b parse<Something> для каждой функции. Затем r; Затем bt на каждом брейкпоинте. Проследите за передачей ключевых аргументов от фрейма к фрейму: frame select <NumOfFrame>
10) Выведите трассы вызовов для каждого брейкпоинта, определите, какую последовательность вызовов они проходят от корневого Parse (считать его нетерминалом S).

---------------------------------------------------------------------------------------------------------------------------

Кроме того, в чатике за полгода было сформулировано некоторое количество "наводящих вопросов", типа "Если есть LL(1)-языки, то что суть LL(0)-языки и как для них устроен парсер, и почему не пользуемся?" и др. Такие вопросы возможны в "пограничных" случаях -- студент хочет больший балл, нежели у него получается. "На понимание". Отвечать придётся развёрнуто.
