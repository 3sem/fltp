# Погружение в LLVM IR — промежуточный код как основа современных компиляторов

## Введение

**Приветствие и постановка проблемы.**
Современная разработка компиляторов сталкивается с вызовом: поддерживать множество языков программирования (C++, Rust, Swift) и множество целевых архитектур (x86, ARM, RISC-V). Написание отдельных компиляторов "под всё" — непосильная задача.
Решение этой проблемы — использование **промежуточного представления (Intermediate Representation — IR)**. LLVM IR — это сердце экосистемы LLVM, язык низкого уровня, но с высокоуровневой информацией, который позволяет решить проблему портабельности и оптимизации.

**Цели семинара:**
1.  Понять роль LLVM IR в современной компиляции.
2.  Изучить основные синтаксические конструкции и структуру IR.
3.  Научиться читать и анализировать .ll файлы.
4.  Рассмотреть практические примеры генерации IR.

---

## Блок 1: Что такое LLVM IR и зачем он нужен? (25 минут)

### 1.1. Место в компиляторе: Трехфазная модель

LLVM IR занимает центральное место в классической трехфазной архитектуре компилятора :
1.  **Фронтенд (Frontend):** Анализирует исходный код (C++, Rust, etc.), строит синтаксическое дерево (AST) и преобразует его в LLVM IR.
2.  **Оптимизатор (Optimizer):** Принимает IR от фронтенда, применяет к нему серию оптимизаций, улучшая код, и передает оптимизированный IR дальше. Оптимизации не зависят ни от исходного языка, ни от целевой платформы.
3.  **Бэкенд (Backend):** Берет оптимизированный IR и генерирует машинный код для конкретной архитектуры (например, x86 или ARM).

### 1.2. Основное назначение (по версии создателей)

Как объясняют разработчики ядра LLVM, IR создан с конкретными целями :
*   **Безопасность и корректность:** В отличие от генерации кода через "строки" (как при трансляции в C), IR генерируется через библиотеки (IRBuilder), что гарантирует создание валидного и типобезопасного кода. Фронтенду не нужно думать о тонкостях целевой платформы.
*   **Абстракция и общность:** Он должен быть достаточно общим, чтобы представлять любые конструкции из языков высокого уровня, и достаточно низкоуровневым, чтобы эффективно отображаться на любые аппаратные архитектуры .
*   **Независимость:** "LLVM IR — это компиляторное IR, а не целевой язык". Он не привязан к семантике конкретного языка (в отличие от C) .

### 1.3. Свойства LLVM IR

*   **Типобезопасность:** Каждая инструкция и значение имеют строго определенный тип (например, `i32`, `float`, `ptr`). Это контрастирует с чистым ассемблером, где операнды — просто байты .
*   **SSA-форма (Static Single Assignment):** Каждая переменная может быть определена (присвоена) только один раз. Это ключевая особенность, упрощающая анализ данных и оптимизацию. Если значение нужно изменить, создается новая переменная .

---

## Блок 2: Синтаксис и структура LLVM IR (45 минут)

### 2.1. Формы представления

LLVM IR может существовать в трех формах, которые полностью эквивалентны:
*   Текстовый формат (`.ll`): То, что мы будем изучать. Читаемый для человека.
*   Биткод (`.bc`): Сериализованная двоичная форма для эффективной передачи между инструментами.
*   In-Memory: Структуры данных и C++ классы (например, `Module`, `Function`, `BasicBlock`) в памяти компилятора.

### 2.2. Базовые элементы синтаксиса

1.  **Комментарии:** Начинаются с `;`.
2.  **Глобальные идентификаторы:** Начинаются с `@` (глобальные переменные, имена функций).
3.  **Локальные идентификаторы:** Начинаются с `%` (локальные переменные, регистры SSA).
4.  **Типы:**
    *   `i32`, `i8`, `i64` — целые числа заданной битности.
    *   `float`, `double` — числа с плавающей точкой.
    *   `ptr` — указатель.
    *   `void` — отсутствие типа (для процедур).
    *   `{ i32, i32 }` — структуры.
    *   `[10 x i32]` — массивы.

### 2.3. Структура модуля: "Программа как контейнер"

Весь код находится в **Модуле (`Module`)** . Модуль содержит:
*   **Объявления функций (Declarations):** Прототипы внешних функций (например, `declare i32 @printf(ptr, ...)`).
*   **Определения функций (Definitions):** Сам код.
*   **Глобальные переменные (Global Variables):** `@my_global = global i32 42`

### 2.4. Функции и базовые блоки

Внутри функции код организован в **базовые блоки (Basic Blocks)**.
*   **Базовый блок (Basic Block):** Это последовательность инструкций, которые выполняются строго друг за другом. Первая инструкция блока — **метка (label)**.
*   **Завершение (Terminator):** Последняя инструкция каждого базового блока обязательно должна быть **терминатором**, который передает управление другому блоку (или завершает функцию). Терминаторы — это `br` (условный/безусловный переход), `ret` (возврат) .

**Пример структуры функции:**
```llvm
define i32 @example(i32 %a) {
entry:                         ; <-- Метка базового блока
  %tmp = add i32 %a, 1         ; <-- Инструкция
  br label %next               ; <-- Терминатор (переход)

next:                          ; <-- Другой блок
  %result = add i32 %tmp, 2
  ret i32 %result              ; <-- Терминатор (возврат)
}
```

### 2.5. Основные инструкции (с примерами)

Рассмотрим несколько ключевых инструкций на примерах трансляции из C .

**Арифметика и приведение типов (кастинг):**
Исходный C код:
```c
int sum = (int)(3.14 + (2 * 4));
```
Соответствующий LLVM IR:
```llvm
; Сначала вычисляется (2 * 4) как i32
%1 = mul i32 2, 4
; Результат приводится к double (sitofp = signed int to float)
%2 = sitofp i32 %1 to double
; Складывается с 3.14 (fadd = float add)
%3 = fadd double 3.14, %2
; Результат приводится обратно к i32 (fptosi = float to signed int)
%4 = fptosi double %3 to i32
; Сохраняется в глобальную переменную @sum
store i32 %4, i32* @sum
```
*Обратите внимание:* Каждая инструкция создает новый SSA-регистр (`%1`, `%2`, ...) .

**Работа с памятью:**
*   `load`: Читает значение из указателя.
*   `store`: Записывает значение в указатель.
*   `alloca`: Выделяет память на стеке текущей функции.

**Работа с составными типами (getelementptr - GEP):**
Инструкция `getelementptr` знаменита своей сложностью, но она необходима для вычисления адресов элементов массивов и структур .
Исходный C код:
```c
int get_element(int *array, int index) {
    return array[index];
}
```
LLVM IR:
```llvm
define i32 @get_element(ptr %array, i32 %index) {
  ; 1. Расширяем индекс до 64 бит (sext = sign extend)
  %1 = sext i32 %index to i64
  ; 2. Вычисляем указатель на элемент: array + index
  %2 = getelementptr inbounds i32, ptr %array, i64 %1
  ; 3. Загружаем значение по вычисленному адресу
  %3 = load i32, ptr %2
  ret i32 %3
}
```
Здесь `getelementptr` не делает ничего, кроме арифметики указателей. Он не обращается к памяти.

**Поток управления:**
*   `br` (условный и безусловный) .
*   `ret` (возврат из функции).
*   `switch` (множественный выбор).

**Особая инструкция PHI (φ):**
Поскольку IR использует SSA-форму, значение не может быть изменено. Переменные версионируются по каждому присвоению (x--> x1 , x2 ..., xn). Как тогда быть с переменными, которые получают разные значения в разных ветках выполнения (в циклах, в ветвлениях)? Для этого нужна инструкция `phi`. Она выбирает значение в зависимости от того, из какого предшествующего базового блока пришло управление.
```llvm
; Упрощенная структура цикла
loop:
  %i = phi i32 [ 0, %entry ], [ %next_i, %loop_body ]
  ; ...
  br i1 %cond, label %loop_body, label %exit
```
Эта инструкция — одна из самых сложных для понимания новичками, но она критически важна для SSA .

---

## Блок 3: Практикум

### 3.1. Инструментарий
*   **`clang -S -emit-llvm file.c -o file.ll`**: Трансляция C в текстовый LLVM IR .
*   **`lli file.ll`**: Непосредственное исполнение IR-файла (Just-In-Time компиляция) .
*   **`opt -pass-name file.ll -S -o file.ll`**: Запуск конкретных оптимизационных проходов над IR.

### 3.2. Задание "Анализ"
Возьмем простую функцию на C:
```c
int max(int a, int b) {
  if (a > b)
    return a;
  else
    return b;
}
```
Транслируем ее в IR без оптимизаций (`clang -S -emit-llvm -O0 max.c`):
```llvm
define i32 @max(i32 %a, i32 %b) {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  store i32 %a, ptr %a.addr, align 4
  store i32 %b, ptr %b.addr, align 4
  %0 = load i32, ptr %a.addr, align 4
  %1 = load i32, ptr %b.addr, align 4
  %cmp = icmp sgt i32 %0, %1
  br i1 %cmp, label %if.then, label %if.else

if.then:
  %2 = load i32, ptr %a.addr, align 4
  store i32 %2, ptr %retval, align 4
  br label %return

if.else:
  %3 = load i32, ptr %b.addr, align 4
  store i32 %3, ptr %retval, align 4
  br label %return

return:
  %4 = load i32, ptr %retval, align 4
  ret i32 %4
}
```
**Обсуждение:**
*   Видим избыточность `alloca/load/store` из-за отключенных оптимизаций (`-O0`). Фронтенд генерирует "сырой" код.
*   Идентифицируем базовые блоки: `entry`, `if.then`, `if.else`, `return`.
*   Видим терминаторы `br` и `ret`.

А теперь с оптимизациями (`clang -S -emit-llvm -O1 max.c`):
```llvm
define i32 @max(i32 %a, i32 %b) local_unnamed_addr #0 {
  %cmp = icmp sgt i32 %a, %b
  %cond = select i1 %cmp, i32 %a, i32 %b
  ret i32 %cond
}
```
**Обсуждение:**
*   Промежуточные действия соптимизировались.
*   Появилась инструкция `select`, которая реализует тернарный оператор .
*   Код стал короче, наглядна работа оптимизатора.

---

## Заключение

**Резюме:**
LLVM IR (и вообще IR) — это мост между входым ЯП и машинным языков. Его основные преимущества:
*   **Единообразие:** Позволяет писать один оптимизатор для всех языков.
*   **Гибкость и универсальность:** Содержит информацию о типах, потоке управления, потоке данных.
*   **Практичность:** Инструменты (Clang, opt).

**Вопросы и ответы.**

---

## Приложение: Материалы для самостоятельного изучения
1.  **Официальная документация:** LLVM Language Reference Manual — основной источник.
2.  **Туториал ЯП Kaleidoscope:** Создание своего языка с кодогенерацией в LLVM IR .
3.  **Онлайн-песочницы:** Godbolt Compiler Explorer — позволяет смотреть IR для любого фрагмента кода.
